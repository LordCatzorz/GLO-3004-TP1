/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
/*                      GLO-3004    PROJET 1    ÉTAPE 1                      */
/*                                                                           */
/*                                 Équipe 11                                 */
/*                                                                           */
/*                     Mathieu Kirouac    111 069 000                        */
/*               Michael Lévesque-Dion    111 090 297                        */
/*                      Raphël Sylvain    111 124 564                        */
/*                                                                           */
/*                                 Hiver 2019                                */
/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */


const CardinaliteBloqueDefaut = 0
const MaxCadinalite = 4
range N_Cardinalite = 1..MaxCadinalite
range COD_Lum = 0..((1 << MaxCadinalite) -1)
set Cardinalite = {cardinalite[N_Cardinalite]}
set DescCardinalite = {nord, est, sud, ouest}
set ActionsVoiture = {continue, tourneDroite, tourneGauche}
set ActionsPieton = {traverse}
set ActionsLumiere = {rouge, vert}
set ActionsComplet = {ActionsLumiere, ActionsPieton, ActionsVoiture}


/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
/* Question 1                                                     (5 points) */
/*                                                                           */
/* Donnez la spécification en FSP d’un processus _VOITURE_ qui représente    */
/* une voiture à l’intersection, peut continuer, tourner à droite ou tourner */
/* à gauche. Ce processus doit être cyclique permettant de modéliser         */
/* plusieurs voitures, faire boucler le processus ne signifie pas que c’est  */
/* la même voiture qui . Le processus _VOITURE_ peut faire les actions       */
/* suivantes, _continue_, _tourneDroite_ ou _tourneGauche_. Ces actions      */
/* signifient ce que leurs noms suggèrent. Après chaque action ce processus  */
/* boucle sur lui même pour représenter le fait qu’une autre voiture         */
/* pourrait arriver.                                                         */
/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

VOITURE = ({ActionsVoiture}->VOITURE).

||Q1 = VOITURE
    /{forall [i:N_Cardinalite] {[@(DescCardinalite, i-1)]/cardinalite[i]}}.

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
/* Question 2                                                     (3 points) */
/*                                                                           */
/* Donnez la spécification en FSP d’un processus _VOITURES_ qui représente   */
/* la mise en parallèle de 3 processus _VOITURE_ correspondant               */
/* respectivement aux voitures venant de l’est, de l’ouest et du sud. Vous   */
/* pouvez préfixer le processus _VOITURE_ par _est_, _ouest_ et _sud_.       */
/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

BLOQUER_CARDINALITE(CardinaliteBloque=CardinaliteBloqueDefaut) = 
        STOP+{
            // Bloquer les actions à partir de la cardinalité bloqué
            cardinalite[CardinaliteBloque].{ActionsComplet}, 
            // Bloquer les actions en direction de la cardinalité bloqué
            cardinalite[(((CardinaliteBloque+1)*(CardinaliteBloque!=0)-1)%MaxCadinalite)+1].tourneDroite,
            cardinalite[(((CardinaliteBloque+2)*(CardinaliteBloque!=0)-1)%MaxCadinalite)+1].continue,
            cardinalite[(((CardinaliteBloque+3)*(CardinaliteBloque!=0)-1)%MaxCadinalite)+1].tourneGauche
            }.
||VOITURES(CardinaliteBloque=CardinaliteBloqueDefaut) = (Cardinalite:VOITURE || BLOQUER_CARDINALITE(CardinaliteBloque))
    // Masquer les actions que nous avons bloqué
    \{cardinalite[CardinaliteBloque],
    cardinalite[(((CardinaliteBloque+1)*(CardinaliteBloque!=0)-1)%MaxCadinalite)+1].tourneDroite,
    cardinalite[(((CardinaliteBloque+2)*(CardinaliteBloque!=0)-1)%MaxCadinalite)+1].continue,
    cardinalite[(((CardinaliteBloque+3)*(CardinaliteBloque!=0)-1)%MaxCadinalite)+1].tourneGauche}.

||Q2 = VOITURES(1)
    /{forall [i:N_Cardinalite] {[@(DescCardinalite, i-1)]
                                /cardinalite[i]}}.

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
/* Question 3                                                     (2 points) */
/*                                                                           */
/* Spécifiez un processus _PIETONS_ qui représente le comportement des       */
/* piétons. Un piéton peut effectuer une seule action _traverse_ puis boucle */
/* sur lui-même                                                              */
/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

PIETONS = (ActionsPieton -> PIETONS).

||Q3 = PIETONS
    /{forall [i:N_Cardinalite] {[@(DescCardinalite, i-1)]/cardinalite[i]}}.

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
/* Question 4                                                     (5 points) */
/*                                                                           */
/* Par souci de simplicité, nous supposons que les lumières peuvent être     */
/* seulement rouge ou verte. Nous supposons que les lumières sont            */
/* initialement toutes rouges. Chacune des lumières passe du rouge au vert   */
/* et inversement.                                                           */
/*                                                                           */
/* Spécifiez un processus _LUMIERE_ qui fait passer une lumière du vert au   */
/* rouge.                                                                    */
/*                                                                           */
/* Spécifiez un processus _LUMIERES_ qui représente la mise en parallèle de  */
/* 3 processus _LUMIERE_ correspondant respectivement aux lumières face à    */
/* l’est, à l’ouest et au sud. Vous pouvez préfixer le processus _LUMIERE_   */
/* par _est_, _ouest_ et _sud_.                                              */
/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

LUMIERE = ROUGE,
ROUGE = (vert -> VERT),
VERT = (rouge -> ROUGE).

||LUMIERES(CardinaliteBloque=CardinaliteBloqueDefaut) = 
    (Cardinalite:LUMIERE || BLOQUER_CARDINALITE(CardinaliteBloque))
    \{cardinalite[CardinaliteBloque],
    cardinalite[(((CardinaliteBloque+1)*(CardinaliteBloque!=0)-1)%MaxCadinalite)+1].tourneDroite,
    cardinalite[(((CardinaliteBloque+2)*(CardinaliteBloque!=0)-1)%MaxCadinalite)+1].continue,
    cardinalite[(((CardinaliteBloque+3)*(CardinaliteBloque!=0)-1)%MaxCadinalite)+1].tourneGauche}.

||Q4 = LUMIERES(1)
    /{forall [i:N_Cardinalite] {[@(DescCardinalite, i-1)]/cardinalite[i]}}.

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
/* Question 5                                                    (30 points) */
/*                                                                           */
/* Spécifiez des processus contrôlant le passage des voitures, des piétons   */
/* et le changement des lumières. Les règles suivantes permettent de         */
/* concevoir ce processus. Vous pouvez l’appeler _CONTROLE_INTERSECTION_     */
/*                                                                           */
/*   1. Les lumières sont toutes rouges au départ.                           */
/*   2. Les piétons ne peuvent traverser que quand toutes les lumières sont  */
/*      rouges.                                                              */
/*   3. Les voitures provenant du sud ne peuvent pas continuer mais          */
/*      seulement tourner à gauche ou tourner à droite.                      */
/*   4. Les voitures provenant de l’est ne peuvent que continuer ou tourner  */
/*      à gauche.                                                            */
/*   5. Les voitures provenant de l’ouest ne peuvent que continuer ou        */
/*      tourner à droite.                                                    */
/*   6. Quand la lumière face à une voiture est verte et que toutes les      */
/*      autres sont rouges, celle-ci peut continuer, tourner à droite ou     */
/*      tourner à gauche si la configuration le permet.                      */
/*   7. Quand la lumière face à une voiture est verte et que celle opposée   */
/*      l’est aussi celle-ci peut continuer ou tourner à droite si la        */
/*      configuration le permet.                                             */
/*   8. On ne peut pas avoir deux lumières adjacentes, est et sud par        */
/*      exemple, vertes en même temps.                                       */
/*   9. On peut avoir deux lumières opposées, est et ouest, par exemple      */
/*      vertes en même temps ou bien l’une verte et l’autre rouge.           */
/*                                                                           */
/* Utilisez les processus déjà spécifiés comme ceci :                        */
/*   ||INTERSECTION = (LUMIERES || PIETONS ||                                */
/*                     VOITURES || CONTROLE_INTERSECTION).                   */
/*                                                                           */
/* Vous n’êtes pas obligés de suivre l’indication suivante, si vous proposez */
/* une solution plus élégante, je saurai apprécier. Indication :             */
/* inspirez-vous de l’exemple du pont et utilisez des indices à un processus */
/* local où la valeur d’un paramètre correspondrait à une lumière rouge ou   */
/* verte. Regardez comment dans cet exemple on a défini une variable qui     */
/* vaut True ou False. Notez que nous pouvons utiliser la conditionnelle     */
/* when avec la même condition autant de fois qu’on veut.                    */
/* Par exemple, when (v==0) a --> P1 when (v==0) b --> P2                    */
/* Utilisez le _RUN_ pour vous assurer que tout fonctionne comme vous le     */
/* voulez.                                                                   */
/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

set SET_NS = {cardinalite[1], cardinalite[3]}
set SET_EO = {cardinalite[2], cardinalite[4]}

MUTEX_DIRECTION = (SET_NS.vert -> NS[1]
    |SET_EO.vert -> EO[1]),
NS[i:1..2] = 
    (when (i == 1) SET_NS.rouge -> MUTEX_DIRECTION
    |when (i > 1) SET_NS.rouge -> NS[i-1]
    |when (i < 2) SET_NS.vert -> NS[i+1]
    ),
EO[i:1..2] = 
    (when (i == 1) SET_EO.rouge -> MUTEX_DIRECTION
    |when (i > 1) SET_EO.rouge -> EO[i-1]
    |when (i < 2) SET_EO.vert -> EO[i+1]
    ).
    
||BLOQUER_LUMIERES_ADJACENTES(CardinaliteBloque=CardinaliteBloqueDefaut) = 
    (LUMIERES(CardinaliteBloque)|| MUTEX_DIRECTION || BLOQUER_CARDINALITE(CardinaliteBloque))
    \{cardinalite[CardinaliteBloque],
    cardinalite[(((CardinaliteBloque+1)*(CardinaliteBloque!=0)-1)%MaxCadinalite)+1].tourneDroite,
    cardinalite[(((CardinaliteBloque+2)*(CardinaliteBloque!=0)-1)%MaxCadinalite)+1].continue,
    cardinalite[(((CardinaliteBloque+3)*(CardinaliteBloque!=0)-1)%MaxCadinalite)+1].tourneGauche}.

// 1 << (Car - 1) = Tout les bits à 0 sauf celui en cours.

CONTROLEUR_INTERSECTION(Car=1) = CONTROLEUR_INTERSECTION[0],
CONTROLEUR_INTERSECTION[cl: COD_Lum] = 
    (cardinalite[i: N_Cardinalite].vert ->  if (((cl >> (i-1))%2) == 0) /*estrouge*/ then CONTROLEUR_INTERSECTION[cl + (1 << (i - 1))] else CONTROLEUR_INTERSECTION[cl]
    |cardinalite[i: N_Cardinalite].rouge -> if (((cl >> (i-1))%2) == 1) /*estvert*/ then CONTROLEUR_INTERSECTION[cl - (1 << (i - 1))] else CONTROLEUR_INTERSECTION[cl]
    // Si tous désactivé, laisser piétons
    |when (cl == 0) traverse -> CONTROLEUR_INTERSECTION[cl]
    // Si seul activé, alors toutes actions permises.
    |when ( (cl - (1<<(Car-1))) == 0) cardinalite[Car].{ActionsVoiture} -> CONTROLEUR_INTERSECTION[cl] 
    // Si lumières opposés activé seulement, alors continuer et tourner droite permise.
    |when ( ((cl - (1<<(Car-1))) - (1<<((((Car-1) + (MaxCadinalite/2)) % MaxCadinalite)))) == 0) cardinalite[Car].{continue, tourneDroite} -> CONTROLEUR_INTERSECTION[cl]
    ).

||CONTROLEUR_INTERSECTIONS(CardinaliteBloque=CardinaliteBloqueDefaut) =
    forall [i:N_Cardinalite]
    (CONTROLEUR_INTERSECTION(i) || BLOQUER_CARDINALITE(CardinaliteBloque))
    \{cardinalite[CardinaliteBloque],
    cardinalite[(((CardinaliteBloque+1)*(CardinaliteBloque!=0)-1)%MaxCadinalite)+1].tourneDroite,
    cardinalite[(((CardinaliteBloque+2)*(CardinaliteBloque!=0)-1)%MaxCadinalite)+1].continue,
    cardinalite[(((CardinaliteBloque+3)*(CardinaliteBloque!=0)-1)%MaxCadinalite)+1].tourneGauche}.

||CONTROLE_INTERSECTION(CardinaliteBloque=CardinaliteBloqueDefaut) = 
    (CONTROLEUR_INTERSECTIONS(CardinaliteBloque) 
    || LUMIERES(CardinaliteBloque) || PIETONS 
    || VOITURES(CardinaliteBloque) || BLOQUER_LUMIERES_ADJACENTES(CardinaliteBloque) 
    || BLOQUER_CARDINALITE(CardinaliteBloque))
    \{cardinalite[CardinaliteBloque],
    cardinalite[(((CardinaliteBloque+1)*(CardinaliteBloque!=0)-1)%MaxCadinalite)+1].tourneDroite,
    cardinalite[(((CardinaliteBloque+2)*(CardinaliteBloque!=0)-1)%MaxCadinalite)+1].continue,
    cardinalite[(((CardinaliteBloque+3)*(CardinaliteBloque!=0)-1)%MaxCadinalite)+1].tourneGauche}.

||CONTROLE_INTERSECTION_SAUF_NORD = 
    CONTROLE_INTERSECTION(1)
    /{forall [i:N_Cardinalite] {[@(DescCardinalite, i-1)]/cardinalite[i]}}.

||Q5 = (CONTROLE_INTERSECTION_SAUF_NORD).


/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
/* Question 6                                                    (10 points) */
/*                                                                           */
/* Pour vous assurer que le processus ||INTERSECTION ne met pas en danger    */
/* les piétons, spécifiez une propriété que vous composerez avec             */
/* ||INTERSECTION pour vous assurer que l’action _traverse_ ne sera jamais   */
/* effectuée quand il y a au moins une lumière verte allumée. Spécifiez un   */
/* processus _TEST1_ pour faire la vérification au moyen de _Check_ de LTSA. */
/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

set DirectionsSaufNord = {est, ouest, sud}

property PIETON_OK_SAUF_NORD = TRAVERSE,
TRAVERSE = 
    (traverse -> TRAVERSE
    | DirectionsSaufNord.vert -> FEU_VERT[1]
    ),

FEU_VERT[nbVert:1..MaxCadinalite] =
    (when (nbVert < MaxCadinalite) DirectionsSaufNord.vert -> FEU_VERT[nbVert+1]
    |when (nbVert > 1) DirectionsSaufNord.rouge -> FEU_VERT[nbVert-1]
    |when (nbVert == 1) DirectionsSaufNord.rouge -> PIETON_OK_SAUF_NORD
    ).

||TEST1 = (CONTROLE_INTERSECTION_SAUF_NORD || PIETON_OK_SAUF_NORD).


/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
/* Question 7                                                    (15 points) */
/*                                                                           */
/* Spécifiez 3 propriétés une par côté de l’intersection servant à garantir  */
/* l’absence de collision.                                                   */
/* Utilisez un processus _TEST2_ pour faire cette vérification.              */
/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
property EST_OK = 
    (est.vert -> EST_VERT
    |ouest.vert -> OUEST_VERT
    |sud.vert -> SUD_VERT),
EST_VERT =
    (ouest.vert -> EST_OUEST_VERT
    |est.rouge -> EST_OK
    |est.{tourneGauche, continue} -> EST_VERT
    ),
OUEST_VERT =
    (ouest.rouge -> EST_OK
    |est.vert -> EST_OUEST_VERT
    ),
SUD_VERT =
    (sud.rouge -> EST_OK),
EST_OUEST_VERT =
    (ouest.rouge -> EST_VERT
    |est.rouge -> OUEST_VERT
    |est.continue -> EST_OUEST_VERT
    ).

property OUEST_OK = 
    (est.vert -> EST_VERT
    |ouest.vert -> OUEST_VERT
    |sud.vert -> SUD_VERT),
EST_VERT =
    (ouest.vert -> EST_OUEST_VERT
    |est.rouge -> OUEST_OK
    ),
OUEST_VERT =
    (ouest.rouge -> OUEST_OK
    |est.vert -> EST_OUEST_VERT
    |ouest.{tourneDroite, continue} -> OUEST_VERT
    ),
SUD_VERT =
    (sud.rouge -> OUEST_OK),
EST_OUEST_VERT =
    (ouest.rouge -> EST_VERT
    |est.rouge -> OUEST_VERT
    |ouest.{tourneDroite, continue} -> EST_OUEST_VERT
    ).

property SUD_OK = 
    (est.vert -> EST_VERT
    |ouest.vert -> OUEST_VERT
    |sud.vert -> SUD_VERT),
EST_VERT =
    (ouest.vert -> EST_OUEST_VERT
    |est.rouge -> SUD_OK
    ),
OUEST_VERT =
    (ouest.rouge -> SUD_OK
    |est.vert -> EST_OUEST_VERT
    ),
SUD_VERT =
    (sud.rouge -> SUD_OK
    |sud.{tourneDroite, tourneGauche} -> SUD_VERT),
EST_OUEST_VERT =
    (ouest.rouge -> EST_VERT
    |est.rouge -> OUEST_VERT
    ).



||TEST2 = (CONTROLE_INTERSECTION_SAUF_NORD || EST_OK || OUEST_OK || SUD_OK).

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
/* Question 8                                                     (5 points) */
/*                                                                           */
/* Spécifiez des ensembles d’actions permettant de vérifier que les piétons  */
/* peuvent toujours traverser l’intersection et que les voitures peuvent     */
/* faire les actions prévues, dans la composition parallèle de la question   */
/* précédente, _TEST2_, représentant le système en entier. À vous de décider */
/* s’il faut spécifier des singletons ou non. Justifiez par une phrase de    */
/* commentaire votre choix. Il ne doit pas y avoir violation de propriétés   */
/* de progrès.                                                               */
/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

// Nous utiliser des singletons, car nous voulons que CHAQUE actions soient toujours réalisable.

// progress PIETONS_PEUT_TRAVERSE = {ActionsPieton}

// progress EST_PEUT_TOURNE_GAUCHE = {est.tourneGauche}
// progress EST_PEUT_CONTINUE = {est.continue}
// progress EST_PEUT_VERT = {est.vert}
// progress EST_PEUT_ROUGE = {est.rouge}

// progress OUEST_PEUT_TOURNE_DROITE= {ouest.tourneDroite}
// progress OUEST_PEUT_CONTINUE = {ouest.continue}
// progress OUEST_PEUT_VERT = {ouest.vert}
// progress OUEST_PEUT_ROUGE = {ouest.rouge}

// progress SUD_PEUT_TOURNE_DROITE= {sud.tourneDroite}
// progress SUD_PEUT_TOURNE_GAUCHE = {sud.tourneGauche}
// progress SUD_PEUT_VERT = {sud.vert}
// progress SUD_PEUT_ROUGE = {sud.rouge}


/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
/* Question 9                                                    (15 points) */
/*                                                                           */
/* Faites toutes les étapes précédentes Q1 à Q8 mais pour l’autre            */
/* intersection. Inspirez-vous de vos solutions, évidemment. Vos processus   */
/* correspondant à ceux des questions Q6 et Q7, s’appelleraient, pas         */
/* obligatoirement, _TEST3_ et _TEST4_.                                      */
/*                                                                           */
/* Notez que pour tester les propriétés de progrès de ces derniers vous      */
/* devez commenter les propriétés de progrès de l’intersection en T, et      */
/* vice-versa.                                                               */
/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */


progress PIETONS_PEUT_TRAVERSE = {ActionsPieton}

progress NORD_PEUT_TOURNE_DROITE = {nord.tourneDroite}
progress NORD_PEUT_TOURNE_GAUCHE = {nord.tourneGauche}
progress NORD_PEUT_CONTINUE = {nord.continue}
progress NORD_PEUT_VERT = {nord.vert}
progress NORD_PEUT_ROUGE = {nord.rouge}

progress EST_PEUT_TOURNE_DROITE = {est.tourneDroite}
progress EST_PEUT_TOURNE_GAUCHE = {est.tourneGauche}
progress EST_PEUT_CONTINUE = {est.continue}
progress EST_PEUT_VERT = {est.vert}
progress EST_PEUT_ROUGE = {est.rouge}

progress SUD_PEUT_TOURNE_DROITE = {sud.tourneDroite}
progress SUD_PEUT_TOURNE_GAUCHE = {sud.tourneGauche}
progress SUD_PEUT_CONTINUE = {sud.continue}
progress SUD_PEUT_VERT = {sud.vert}
progress SUD_PEUT_ROUGE = {sud.rouge}

progress OUEST_PEUT_TOURNE_DROITE = {ouest.tourneDroite}
progress OUEST_PEUT_TOURNE_GAUCHE = {ouest.tourneGauche}
progress OUEST_PEUT_CONTINUE = {ouest.continue}
progress OUEST_PEUT_VERT = {ouest.vert}
progress OUEST_PEUT_ROUGE = {ouest.rouge}



property PIETON_OK = TRAVERSE,
TRAVERSE = 
    (traverse -> TRAVERSE
    | DescCardinalite.vert -> FEU_VERT[1]
    ),

FEU_VERT[nbVert:1..MaxCadinalite] =
    (when (nbVert < MaxCadinalite) DescCardinalite.vert -> FEU_VERT[nbVert+1]
    |when (nbVert > 1) DescCardinalite.rouge -> FEU_VERT[nbVert-1]
    |when (nbVert == 1) DescCardinalite.rouge -> PIETON_OK
    ).

property NS_OK = 
    (nord.vert -> NORD_VERT
    |est.vert -> EST_VERT
    |sud.vert -> SUD_VERT
    |ouest.vert -> OUEST_VERT),
EST_VERT =
    (est.rouge -> NS_OK
    |ouest.vert -> EST_OUEST_VERT),
OUEST_VERT = 
    (ouest.rouge -> NS_OK
    |est.vert -> EST_OUEST_VERT),
EST_OUEST_VERT = 
    (est.rouge -> OUEST_VERT
    |ouest.rouge -> EST_VERT),
NORD_VERT =
    (nord.ActionsVoiture -> NORD_VERT
    |nord.rouge -> NS_OK
    |sud.vert -> NORD_SUD_VERT),
SUD_VERT =
    (sud.ActionsVoiture -> SUD_VERT
    |sud.rouge -> NS_OK
    |nord.vert -> NORD_SUD_VERT),
NORD_SUD_VERT =
    (nord.rouge -> SUD_VERT
    |sud.rouge -> NORD_VERT
    |{nord, sud}.{continue, tourneDroite} -> NORD_SUD_VERT).
    
property EO_OK = 
    (ouest.vert -> OUEST_VERT
    |nord.vert -> NORD_VERT
    |est.vert -> EST_VERT
    |sud.vert -> SUD_VERT),
NORD_VERT =
    (nord.rouge -> EO_OK
    |sud.vert -> NORD_SUD_VERT),
SUD_VERT = 
    (sud.rouge -> EO_OK
    |nord.vert -> NORD_SUD_VERT),
NORD_SUD_VERT = 
    (nord.rouge -> SUD_VERT
    |sud.rouge -> NORD_VERT),
OUEST_VERT =
    (ouest.ActionsVoiture -> OUEST_VERT
    |ouest.rouge -> EO_OK
    |est.vert -> OUEST_EST_VERT),
EST_VERT =
    (est.ActionsVoiture -> EST_VERT
    |est.rouge -> EO_OK
    |ouest.vert -> OUEST_EST_VERT),
OUEST_EST_VERT =
    (ouest.rouge -> EST_VERT
    |est.rouge -> OUEST_VERT
    |{ouest, est}.{continue, tourneDroite} -> OUEST_EST_VERT).

||CONTROLE_INTERSECTION_X= 
    CONTROLE_INTERSECTION(0)
    /{forall [i:N_Cardinalite] {[@(DescCardinalite, i-1)]/cardinalite[i]}}.

||TEST3 = (CONTROLE_INTERSECTION_X || PIETON_OK).
||TEST4 = (CONTROLE_INTERSECTION_X || EO_OK || NS_OK).

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
/* Question 10                                                   (10 points) */
/*                                                                           */
/* Spécifiez un processus _TEST5_ qui met en parallèle _TEST2_ et _TEST4_.   */
/* Vous pouvez préfixer les processus de l’intersection en T par [1] et ceux */
/* de l’autre par [2] pour maximiser la réutilisation. Vérifier les          */
/* propriétés définies dans les questions précédentes ainsi que les          */
/* propriétés de progrès. Utilisez le renommage de certaines actions pour    */
/* synchroniser les lumières. Ainsi les lumières est et ouest des deux       */
/* intersections doivent êtres, rouges ou vertes, en même temps. La même     */
/* chose pour les lumières côté sud de l’intersection et sud en T et nord de */
/* l’autre. Renommez aussi les actions montrant la continuité des            */
/* intersections ainsi une voiture venant du nord de la deuxième             */
/* intersection et qui tournerait à gauche serait une voiture qui continue   */
/* en provenance de l’ouest pour l’intersection en T.                        */
/*                                                                           */
/* Pour tester le progrès nous avons besoin de toutes les actions servant à  */
/* définir les propriétés précédentes sauf celles renommées différemment. Il */
/* ne devrait y avoir ni blocage ni violation de propriétés ni de violation  */
/* de progrès.                                                               */
/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */








